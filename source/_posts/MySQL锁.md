---
title: MySQL锁
date: 2024-04-29 10:03
tags:
  - MySQL
categories:
  - 学习
---

## 个人理解，不对的地方请指正

当前系统 MySQL 版本为：8.0.28

全局锁（Server 层提供）：
 - 通过 ```Flush tables with read lock;``` 上锁
 - 通过 ```unlock tables;``` 解锁
 - 使用场景：开启后整个库完全处于只读状态，用于做全库逻辑备份

表级锁（Server 层提供）：
 - 表锁：手动释放
   - 需要显式使用 ```lock table t read/write;``` 加锁，```unlock tables;``` 解锁
   - 读读不互斥，可以有多个线程同时对同一个表上读锁，也就是：```lock table t read;``` 但是上读锁的线程，自己也不可以往表 t 插入数据，否则会报错：```Table 't' was locked with a READ lock and can't be updated;```
   - 读写互斥，当其他线程持有表 t 的读锁时，当前线程想要修改表 t 的数据需要等待读锁释放（当其他线程持有表 t 的写锁时，当前线程想要读取表 t 的数据需要等待写锁释放）
   - 写写互斥，当其他线程持有表 t 的写锁时，当前线程想要修改表 t 的数据需要等待其他线程释放写锁
 - 元数据锁（MDL：metadata lock）：
   - 不需要显式使用，访问一个表的时候会自动加上，但是在事务结束时才会释放。
   - MDL锁是针对表结构的，而不是针对表的，所以线程对表里面的数据进行增删改查时只需要获取 MDL 的读锁，而不需要获取写锁。当线程进行表结构的操作，如：```alter table t add f int;``` 这类操作时，才需要获取 MDL 写锁
   - 读读不互斥，所以多个线程可以同时对同一个表进行增删改查
   - 读写互斥，当有线程对表 t 进行增删改查时，当前线程不可以修改表 t 的表结构（当有线程修改表 t 的表结构时，当前线程不可以对表 t 增删改查）
   - 写写互斥，多个线程不能同时修改表 t 的表结构

行锁（InnoDB 提供）：
 - 在需要的时候加上，锁住某一行记录。但是行锁在事务结束时才会释放，所以尽量将最影响并发的锁往后放
 - 读读不互斥，多个线程可以同时对同一行的数据加读锁
 - 读写互斥，当有线程加读锁时，另一个线程不可以修改数据（当有线程修改数据时，另一个线程不可以加读锁）
 - 写写互斥，多个线程不可以同时修改同一行数据

间隙锁（InnoDB 提供）：
 - 由于行锁只能锁住行，而插入操作要更新的是行与行之间的间隙。因此，为了解决幻读问题，InnoDB 只好引入间隙锁（Gap Lock），每个间隙锁是开区间，如：(0，5)
 - 间隙锁是可重复读事务级别才存在的，所以如果把隔离级别改成读提交，就没有间隙锁了。
 - 当有线程给某个间隙加上间隙锁时，当前线程不能对该间隙进行数据插入操作，但是可以给该间隙加间隙锁。也就是说，多个线程可以同时对同个间隙加上间隙锁，但是这样会带来一个问题：当线程 A 和 B 同时持有间隙锁 (0, 5)，并且线程 A 和 B 同时往间隙 (0, 5) 进行插入操作时，线程 A 和 B 会互相等待对方释放间隙锁，导致死锁，此时 InnoDB 的死锁检测马上就发现了这对死锁关系，让最后进行插入的线程的 insert 语句报错返回

next-key lock（InnoDB 提供）：
 - 间隙锁与行锁合称为 next-key lock，每个 next-key lock 是前开后闭区间，如：(0，5]
 - 加 next-key lock 时，先往间隙加锁，再加行锁。如：```update t set d = d + 1 where c = 10;``` 会先给(5, 10) 的间隙加锁，再加上 c = 10 的行锁

InnoDB 加锁规则：
 - 原则 1：加锁的基本单位是 next-key lock
 - 原则 2：查找过程中访问到的对象才会加锁。
 - 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁
 - 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁
