---
title: MySQL索引
date: 2024-04-29 10:03
tags:
  - MySQL
categories:
  - 学习
---

## 个人理解，不对的地方请指正

索引的常见模型：
 - 哈希表
   * key-value 结构，查询速度快，时间复杂度为 O(1)
   * 由于是根据哈希算法来插入数据，位置是不确定的，如果进行范围查询，只能进行全表扫描，时间复杂度为 O(N)，所以适用于只有等值查询的场景
 - 有序数组
   * 有序的数组可以使用二分查询，所以等值查询和范围查询的性能都很高，时间复杂度为 O(log(N))
   * 由于要支持有序，所以插入元素时需要进行元素的移动，导致成本比较高，所以适用于静态存储引擎
 - 二叉搜索树
   * 二叉搜索树的优势在于父节点左子树所有节点的值都小于父节点的值，而右子树所有节点的值大于父节点的值，查询的时候可以利用这个特点进行二分查找，时间复杂度为 O(log(N))
   * 由于为了维持这棵树是二叉搜索树，每次更新时需要进行维护，更新的时间的复杂度是 O(log(N))
   * 虽然二叉搜索树在多叉树中查询效率是最高的，但是由于二叉搜索树只有两个子节点，导致树高会比较高，一棵 100 万节点的二叉搜索树，树高为 20。一次查询可能要访问 20 个数据块。所以为了让一个查询尽量少读磁盘，就必须让查询过程访问尽量少的数据库，那么就需要使用“N叉”树，而不是二叉树，“N叉”树中的“N”取决于数据库的大小。而如果只是在内存中，二叉搜索树是最优的。
 - B 树（也叫 B- 树，B 代表 Balanced）
   * B 树的所有节点都存放 key 和 data
   * B 树的叶子节点都是独立的
   * B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了
   * B 树进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；
 - B+ 树
   * B+ 树只有叶子节点存放 key 和 data，其他内节点只存放 key
   * B+ 树的叶子节点有一条引用链指向与它相邻的叶子节点
   * B+ 树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程
   * B+ 树的范围查询，只需要对链表进行遍历即可
   * InnoDB 选用的就是 B+ 树
 
MySQL 中索引的类型：
 - 聚簇索引：叶子节点存放的是整行的数据，一张表中只有一个
   * 主键索引：不可重复，不可为 null
 - 非聚簇索引：叶子节点存放的是主键的值，查询拿到主键的值后可能需要回表再扫描一次获取行信息
   * 普通索引：可以重复，可以为 null
   * 唯一索引：不可重复，但可以为 null
   * 前缀索引：可以重复，可以为 null。前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通e索引更小
   * 全文索引：可以重复，可以为 null。对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替

假设有表结构：
```sql
create table `t` (
  `id` int not null,
  `c` int default null,
  `d` int default null,
  primary key (`id`),
  key `c` (`c`)
) engine = InnoDB;
insert into t values (1, 1, 1), (2, 2, 2), (15,15,15);
```
索引优化查询方式（使用上述表结构）：
 - 覆盖索引：如果一个 SQL 语句，如 ```select id from t where c = 1```，其中 c 是表 t 的普通索引，id 是表 t 的主键。该语句使用索引 c 进行查询，首先到索引 c 的 B+ 树中获取到主键，也就是 id，由于需要查询获取的数据只有 id，刚好普通索引（非聚簇索引）叶子节点存的是主键的值，此时无需再拿 id 回主键的索引树查询，而是直接返回数据。而如果把上述查询语句改为 ```select c from t where c = 1``` 的效果也是一样的，因为 c 本身就是索引，只有查询到别的值时才需要回表，如 ```select d from t where c = 1```
 - 联合索引：多列的字段组成一个索引，如表 t 的 c、d 字段创建索引 ```alter table t add index idx_c_d(`c`, `d`)```。联合索引遵循最左匹配原则，|建立索引 idx_c_d 时，如果查询条件为 ```where c = 1``` 或者 ```where c = 1 and d = 1``` 或者 ```where d = 1 and c = 1``` 都可以用到索引，但是如果查询条件为 ```where d = 1``` 则不行，因为索引先建立在 c 上后建立在 d 上
 - 最左前缀原则：不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。
 - 索引下推：MySQL 在 5.6 版本新加的优化回表的功能，5.6 版本以前都不支持。使用命令 ```set session optimizer_switch = 'index_condition_pushdown = off/on';``` 关闭或开启，开启索引下推前，当查询条件中包含有索引，如 ```select * from t where c > 1 and d = 5;``` MySQL 会直接拿着满足 c > 1 的数据的主键回表查询。开启索引下推后，MySQL 查询到 c > 1 的数据后，会先把 d != 5 的数据进一步筛选掉，然后再进行回表查询，省略了 d != 5 的数据的回表查询操作

避免索引失效的一些场景：
 - 创建了组合索引，但查询条件未遵守最左匹配原则
 - 在索引列上进行计算、函数、类型转换等操作
 - 以 % 开头的 LIKE 查询比如 like '%abc'
 - 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到
 - 发生隐式转换

通过 explain 分析 SQL 语句：
|列名|含义|
|:-:|:-:|
|id|select 查询的序列标识符|
|select_type|select 关键字对应的查询类型|
|table|用到的表名|
|partitions|匹配的分区，对于未分区的表，值为 NULL|
|type|表的访问方法|
|possible_keys|可能用到的索引|
|key|实际用到的索引|
|key_len|所选索引的长度|
|ref|当使用索引等值查询时，与索引作比较的列或常量|
|rows|按表条件过滤后，留存的记录数的百分比|
|filtered|按表条件过滤后，留存的记录数的百分比|
|Extra|附加信息|

其中重要的列有：
 - type：
   * system：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例
   * const：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件
   * eq_ref：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件
   * ref：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行
   * index_merge：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引
   * range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了
   * index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。
   * ALL：全表扫描
 - Extra:
   * Using filesort：在排序时使用了外部的索引排序，没有用到表内索引进行排序。
   * Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。
   * Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。
   * Using index condition：表示查询优化器选择使用了索引条件下推这个特性。
   * Using where：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。
   * Using join buffer (Block Nested Loop)：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。
