---
title: 刷题笔记
date: 2024-04-29 10:03
categories:
  - 学习
---

# 刷题笔记
## 1. 题目分类：
题目分类大致如下：
![image](https://i.postimg.cc/28pbJSQk/P-F-OK0-J6-Q8-OIKOQ2-V33-WV123.png)

## 2. 贪心算法
采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的。

---

### [455. 分发饼干（Easy）](https://leetcode-cn.com/problems/assign-cookies)
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例：**
```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**代码：**
```
public class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int biscuitNum = 0;
        int amount = 0;
        while (amount < g.length) {
            while (biscuitNum < s.length && s[biscuitNum] < s[amount]) {
                biscuitNum++;
            }
            if (biscuitNum >= s.length) {
                break;
            }
            if (s[biscuitNum] >= g[amount]) {
                amount++;
            }
            biscuitNum++;
        }
        return amount;
    }
}
```

**解题思路：**
此题的局部最优为：尽量让小饼干给胃口小的孩子吃。因此将孩子和饼干都从小到大排序一一满足即可。

**贪心策略：**
尽量让小饼干给胃口小的孩子吃。

---

### [135.分发糖果（Hard）](https://leetcode-cn.com/problems/candy/)
n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 1 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目。

**示例：**
```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**代码：**
```
public class Solution {
    public static int candy(int[] ratings) {
        int length = ratings.length;
        if (length < 2) {
            return length;
        }
        int[] candyArray = new int[length];
        Arrays.fill(candyArray, 1);
        for (int i = length - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                candyArray[i] = candyArray[i + 1] + 1;
            }
        }
        int amount = 0;
        for (int i = 0; i < length - 1; i++) {
            if (ratings[i + 1] > ratings[i] && candyArray[i + 1] <= candyArray[i]) {
                candyArray[i + 1] = candyArray[i] + 1;
            }
            amount += candyArray[i];
        }
        amount += candyArray[length - 1];
        return amount;
    }
}
```
**解题思路：**
首先初始化所有孩子的糖果为1，当第一次从右往左扫描时，如果左边孩子比右边孩子的评分要高，则让左孩子的糖果数量为右孩子糖果数量加1即可。第二次反方向（从左往右）扫描，如果右边孩子的评分比左边孩子的要高，并且右边孩子的糖果数量不大于左边孩子时，更新右边孩子的糖果数量为左边孩子的糖果数量加1即可。

**贪心策略：**
在每次遍历中，只考虑并更新相邻一侧的大小关系。

---

### [435. 无重叠区间（Medium）](https://leetcode-cn.com/problems/non-overlapping-intervals/)
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**注意：**
- 可以认为区间的终点总是大于它的起点。
- 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

**示例：**
```
输入: [ [1,2], [2,3], [3,4], [1,3] ]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**代码：**
```
public class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) {
            return 0;
        }
        Arrays.sort(intervals, ((o1, o2) -> {
            return o1[1] - o2[1];
        }));
        int total = 0;
        int pre = intervals[0][1];
        for (int i = 1; i < intervals.length; i++) {
            if (pre > intervals[i][0]) {
                total++;
            } else {
                pre = intervals[i][1];
            }
        }
        return total;
    }
}
```

**解题思路：**
这题我们只需要关注每个区间的右边界即可，对于每个区间，我们希望他的右区间越小越好，这样能够剩余的区间则越多，所以只需要按区间的右边界从小到大排序即可。

**贪心策略：**
尽量取右边界较小的区间

---

### [605. 种花问题（Easy）](https://leetcode-cn.com/problems/can-place-flowers/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。

**示例：**
```
输入：flowerbed = [1,0,0,0,1], n = 1
输出：true
```

**代码：**
```
public class Solution {
    public static boolean canPlaceFlowers(int[] flowerbed, int n) {
        int length = flowerbed.length;
        for (int i = 0; i < length; i++) {
            if (flowerbed[i] == 1) {
                continue;
            }
            if (i > 0) {
                if (flowerbed[i - 1] == 1) {
                    continue;
                }
            }
            if (i < length - 1) {
                if (flowerbed[i + 1] == 1) {
                    continue;
                }
            }
            flowerbed[i] = 1;
            n--;
            if (n <= 0) {
                break;
            }
        }
        return n <= 0;
    }
}
```

**解题思路：**
哪里有空往哪种，种的时候判断左右是否有花即可，注意首尾判断越界问题

**贪心策略：**
哪里有空往哪种

---

### [452. 用最少数量的箭引爆气球（Medium）](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)
在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart, xend]，返回引爆所有气球所必须射出的最小弓箭数。

**示例：**
```
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
```

**代码：**
```
public class Solution {
    public static int findMinArrowShots(int[][] points) {

        Arrays.sort(points, (Comparator.comparingInt(o -> o[1])));
        if (points.length <= 0) {
            return 0;
        }

        int total = 1;
        int pre = points[0][1];
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] <= pre) {
                continue;
            }
            pre = points[i][1];
            total++;
        }
        return total;
    }
}
```

**解题思路：**
先把区间按右边界从小到大排序，定义一个初始右边界，遍历所有区间，满足右边界比初始右边界小的都可以用一支箭引爆，当不满足时，取新边界为当前右边界，所需箭加1，重复上述操作。

**贪心策略：**
使区间重叠的气球都用同一支箭引爆

---

### [763. 划分字母区间（Medium）](https://leetcode-cn.com/problems/partition-labels/)
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

**示例：**
```
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
```

**代码：**
```
public class Solution {
    public static List<Integer> partitionLabels(String s) {
        int[] letterPos = new int[26];
        for (int i = 0; i < s.length(); i++) {
            letterPos[s.charAt(i) - 'a'] = i;
        }

        int start = 0, end = 0;
        List<Integer> resultList = new ArrayList<>();
        for (int i = 0; i < s.length(); i++) {
            end = Math.max(end, letterPos[s.charAt(i) - 'a']);
            if (i == end) {
                resultList.add(end - start + 1);
                start = end + 1;
            }
        }
        return resultList;
    }
}
```

**解题思路：**
初始化一个字符数组，存储每个字符的最后位置，定义一个字符串起始和结束位置，每次更新所需字母的最大长度，即字符串的结束位置，当当前遍历位置与字符串结束位置相等时，则说明该字符串已满足条件，更新字符串开始位置。

**贪心策略：**
由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。

---

### [122. 买卖股票的最佳时机 II（Easy）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**
你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例：**
```
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3。
```

**代码：**
```
public class Solution {
    public static int maxProfit(int[] prices) {
        int total = 0;
        int start = Integer.MAX_VALUE;
        for (int i = 0; i < prices.length; i++) {
            if (start < prices[i]) {
                total += prices[i] - start;
            }
            start = prices[i];
        }
        return total;
    }
}
```

**解题思路：**
遍历每天股票的价格并且更新当前持有的股票价格，当第二天比前一天的股票价格高时，就马上卖出股票

**贪心策略：**
卖出股票价格比买入股票价格高时马上卖出

---

### [406. 根据身高重建队列（Medium）](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi，前面正好有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

**示例：**
```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

**代码：**
```
public class Solution {
    public static int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);
        List<int[]> resultList = new ArrayList<>();
        for (int i = 0; i < people.length; i++) {
            resultList.add(people[i][1], people[i]);
        }
        return resultList.toArray(new int[0][0]);
    }
}
```

**解题思路：**
先按身高从高到低排，再按比当前人高的个数从小到大排序，然后一个一个插入即可（因为矮的即使在高的前面也不会影响高的人的个数）

**贪心策略：**
按身高从高到低插入即可，矮的人插入后不会影响高的人

---

### [665. 非递减数列（Medium）](https://leetcode-cn.com/problems/non-decreasing-array/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
给你一个长度为 n 的整数数组，请你判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的：对于数组中任意的 i (0 <= i <= n - 2)，总满足 nums[i] <= nums[i + 1]。

**示例：**
```
输入: nums = [4,2,3]
输出: true
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
```

**代码：**
```
public class Solution {
    public static boolean checkPossibility(int[] nums) {
        int total = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] > nums[i + 1]) {
                total++;
                if (total > 1) {
                    return false;
                }
                if (i > 0 && nums[i - 1] > nums[i + 1]) {
                    nums[i + 1] = nums[i];
                }
            }
        }
        return true;
    }
}
```

**解题思路：**
本题是要维持一个非递减的数列，所以遇到递减的情况时（nums[i] > nums[i + 1]），要么将前面的元素缩小，要么将后面的元素放大。

但是本题唯一的易错点就在这：

- 如果将nums[i]缩小，可能会导致其无法融入前面已经遍历过的非递减子数列；
- 如果将nums[i + 1]放大，可能会导致其后续的继续出现递减；

所以要采取贪心的策略，在遍历时，每次需要看连续的三个元素，也就是瞻前顾后，遵循以下两个原则：

- 需要尽可能不放大nums[i + 1]，这样会让后续非递减更困难；
- 如果缩小nums[i]，但不破坏前面的子序列的非递减性；

**贪心策略：**
遇到下一个元素比当前元素小时则进行修改

---

## 3. 双指针算法（多指针）
- 双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多
个数组的多个指针。
- 若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的
区域即为当前的窗口），经常用于区间搜索。
- 若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是
排好序的。

---

### [142. 环形链表 II（Medium）](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。

为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。

**注意：**
pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

**示例：**
```
输入：head = [3, 2, 0, -4]
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```
![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

**代码：**
```
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
        val = x;
        next = null;
    }
}
 
public class Solution {
    public static ListNode detectCycle(ListNode head) {
        ListNode p2 = head;
        ListNode p3 = head;
        while (null != p3) {
            p2 = p2.next;
            if (null != p3.next) {
                p3 = p3.next.next;
            } else {
                return null;
            }
            if (p2 == p3) {
                ListNode p1 = head;
                while (p1 != p2) {
                    p1 = p1.next;
                    p2 = p2.next;
                }
                return p1;
            }
        }
        return null;
    }
}
```

**解题思路：**
使用双指针 fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。

如图所示，设链表中环外部分长度为 a。slow 指针进入环后与 fast 指针相遇所走的距离为b，剩余距离为 c。

![image](https://assets.leetcode-cn.com/solution-static/142/142_fig1.png)

当 fast 指针与 flow 指针相遇时，有：
- fast 指针已经走完了环的 n 圈，因此它走过的总距离为：a + n * (b + c) + b = a + (n + 1) * b + n * c
- 而 b 走过的距离为 a + b

那么 根据 a 和 b 的快慢关系可以得出：
- a + (n + 1) * b + n * c = 2 * (a + b)
- 进一步可以推出：(n - 1) * b + n * c - a = 0
- 得：a = c + (n - 1) * (b + c)

根据公式可以知道 a 和 c 的长度是相等的，那么只要当 fast 指针和 slow 指针相遇时，我们再让一个指针从 a 的起点出发，那么该指针和 slow 指针会在环的入口处和 slow 指针相遇，就可以得到环入口处的链表结点。

---

### [76. 最小覆盖子串（Hard）](https://leetcode-cn.com/problems/minimum-window-substring/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

**注意：**
- 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
- 如果 s 中存在这样的子串，我们保证它是唯一的答案。

**示例：**
```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**代码：**
```
public class Solution {
    public static String minWindow(String s, String t) {
        int p1 = 0;
        int p2 = 0;
        HashMap<Character, Integer> letterMap = new HashMap<>();
        HashMap<Character, Integer> targetMap = new HashMap<>();
        String result = s + " ";
        for (int i = 0; i < t.length(); i++) {
            updateHashMap(targetMap, t.charAt(i), 1);
        }
        while (p2 < s.length()) {
            updateHashMap(letterMap, s.charAt(p2), 1);
            if (isSatisfied(letterMap, targetMap)) {
                do {
                    result = getResult(result, s.substring(p1, p2 + 1));
                    updateHashMap(letterMap, s.charAt(p1), -1);
                    p1++;
                } while (isSatisfied(letterMap, targetMap));
            }
            p2++;
        }
        return result.length() > s.length() ? "" : result;
    }

    public static boolean isSatisfied(HashMap<Character, Integer> letterMap,
                                      HashMap<Character, Integer> targetMap) {
        for (Map.Entry<Character, Integer> entry : targetMap.entrySet()) {
            Character key = entry.getKey();
            Integer letterResult = letterMap.get(key);
            if (null == letterResult) {
                return false;
            }
            Integer targetResult = targetMap.get(key);
            if (letterResult < targetResult) {
                return false;
            }
        }
        return true;
    }

    public static void updateHashMap(HashMap<Character, Integer> hashMap, char c, Integer amount) {
        hashMap.merge(c, amount, Integer::sum);
    }

    public static String getResult(String origin, String after) {
        if (origin.length() > after.length()) {
            return after;
        }
        return origin;
    }
}
```

**解题思路：**
该题使用滑动窗口，定义 p1 和 p2 两个指针，当不满足条件时，窗口一直扩大，即 p2 指针一直向后移动，直到满足题目条件。此时，p1 指针可以慢慢向前移动，缩小窗口，直到不符合条件。一直循环上述步骤直到 p1 指针与 p2 指针相等即可。缩小窗口时，满足条件的字符串与当前记录的字符串比较，若长度比当前的小，则替换。

---

## 4. 二分查找
- 二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取
一部分继续查找，将查找的复杂度大大减少。对于一个长度为 O(n) 的数组，二分查找的时间复
杂度为 O(log n)。

### [81. 搜索旋转排序数组 II（Medium）](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/submissions/)
已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k + 1], ..., nums[n - 1], nums[0], nums[1], ..., nums[k - 1]]（下标 从 0 开始 计数）。例如， [0, 1, 2, 4, 4, 4, 5, 6, 6, 7] 在下标 5 处经旋转后可能变为 [4, 5, 6, 6, 7, 0, 1, 2, 4, 4] 。

给你旋转后的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。

**示例：**
```
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
```

**代码：**
```
public class Solution {
    public static boolean search(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        while (low <= high) {
            int middle = (high - low) / 2 + low;
            if (target == nums[middle]) {
                return true;
            }
            if (nums[low] == nums[middle] && nums[middle] == nums[high]) {
                low++;
                high--;
            } else if (nums[low] <= nums[middle]) {
                if (nums[low] <= target && target < nums[middle]) {
                    high = middle - 1;
                } else {
                    low = middle + 1;
                }
            } else {
                if (nums[middle] < target && target <= nums[high]) {
                    low = middle + 1;
                } else {
                    high = middle - 1;
                }
            }
        }
        return false;
    }
}
```

**解题思路：**
由于原来的数组是一个非降序的数组，数组旋转后，会变成两段非降序的区间，所以每次二分查找时，需要判断在哪一个区间，一共有以下三种情况：
- 当 mid 值和 left 值以及 right 值都相等时，无法判断哪一边是非降序区间，此时让 left + 1，right - 1 即可，由于中间值跟这两个值相等，不用担心会漏掉这个值。
- 当 mid 值 < left 值时，说明数组中 mid 到 right 这段区间是非降序的，此时我们判断 target 是否处于 mid 和 right 中，如果不是说明 target 处于 left 到 mid 的区间，让 right = mid - 1 即可。如果是则让 left = mid + 1；
- 当 mid 值 >= left 值时，说明数组中 left 到 mid 这段区间是非降序的，此时我们判断 target 是否处于 left 和 mid 中，如果不是说明 target 处于 mid 到 right 的区间，让 left = mid + 1 即可。如果是则让 right = mid - 1；

---

### [154. 寻找旋转排序数组中的最小值 II（Hard）](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。

例如原数组 nums = [0, 1, 4, 4, 5, 6, 7] 在变化后可能得到：
- 若旋转 4 次，则可以得到 [4, 5, 6, 7, 0, 1, 4]
- 若旋转 7 次，则可以得到 [0, 1, 4, 4, 5, 6, 7]

**注意：**
数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次的结果为数组 [a[n - 1], a[0], a[1], a[2], ..., a[n - 2]] 。

**示例：**
```
输入：nums = [1,3,5]
输出：1
```

**代码：**
```
public class Solution {
    public static int findMin(int[] nums) {
        int l = 0;
        int h = nums.length - 1;
        while (l <= h) {
            int m = (h - l) / 2 + l;
            if (nums[h] < nums[m]) {
                l = m + 1;
            } else if (nums[h] > nums[m]) {
                h = m;
            } else {
                h--;
            }
        }
        return nums[l];
    }
}
```

**解题思路：**
这题跟81. 搜索旋转排序数组思路一样，旋转数组后，数组中可能会出现两个升序区间，最小值位于两个升序区间的隔断处，所以分成三种情况讨论：
- 当 h 的值大于 m 的值，说明该区间是升序区间，由于要找最小值，肯定处于 l 和 m 之间，使 h = m
- 当 h 的值小于 m 的值，说明该区间包含两个升序区间的隔断处，所以最小值肯定处于 l 和 m 之间，使 l = m + 1
- 当 h 的值等于 m 的值，无法判断，使得 h 减 1 即可

---

### [4. 寻找两个正序数组的中位数（Hard）](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/submissions/)
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数 。

**注意：** 
算法的时间复杂度应该为 O(log (m+n)) 。

**示例：**
```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**代码：**
```
public class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {

        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            // 边界情况
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }
            
            // 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }
    }
}
```

**解题思路：**
根据中位数的定义有一下两种情况：
- 当 m + n 是奇数时，中位数是两个有序数组中的第 (m + n) / 2 个元素
- 当 m + n 是偶数时，中位数是两个有序数组中的第 (m + n) / 2 个元素和第 (m + n) / 2 + 1 个元素的平均值。

因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m + n) / 2 或 (m + n) / 2 + 1

有以下三种情况需要特殊处理：

- 如果 A[k / 2 − 1] 或者 B[k / 2 − 1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k / 2。
- 如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。
- 如果 k = 1，我们只要返回两个数组首元素的最小值即可。         

---

## 5. 排序算法
![image](https://img2018.cnblogs.com/blog/849589/201903/849589-20190306165258970-1789860540.png)
![image](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)
**相关概念：**
- 稳定：如果a原本在b前面，而a = b，排序之后a仍然在b的前面。
- 不稳定：如果a原本在b的前面，而a = b，排序之后 a 可能会出现在 b 的后面。
- 时间复杂度：对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律。
- 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。

---

### [912. 排序树组（Medium）](https://leetcode-cn.com/problems/sort-an-array/)
给你一个整数数组 nums，请你将该数组升序排列。

**示例：**
```
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```

**快速排序代码：**
```
public class Solution {
    // 从小到大
    // 基准值在前
    public static void quickMinToMaxSort(int[] nums, int start, int end) {
        if (start >= end) {
            return;
        }
        int random = (int) (Math.random() * (end - start + 1)) + start;
        swap(nums, random, start);
        int index = end + 1;
        int pivot = nums[start];
        for (int l = end; l > start; l--) {
            if (nums[l] > pivot) {
                index--;
                swap(nums, l, index);
            }
        }
        index--;
        swap(nums, index, start);

        quickMinToMaxSort(nums, start, index - 1);
        quickMinToMaxSort(nums, index + 1, end);
    }
    
    // 从大到小
    // 基准值在后
    public static void quickMaxToMinSort(int[] nums, int start, int end) {
        if (start >= end) {
            return;
        }
        int random = (int) (Math.random() * (end - start + 1)) + start;
        swap(nums, random, end);
        int pivot = nums[end];
        int index = start - 1;
        for (int i = start; i < end; i++) {
            if (nums[i] >= pivot) {
                index++;
                swap(nums, index, i);
            }
        }
        index++;
        swap(nums, index, end);

        quickMaxToMinSort(nums, start, index - 1);
        quickMaxToMinSort(nums, index + 1, end);
    }

    public static void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```

**归并排序代码：**
```
public class Solution {
    public static void sort(int[] mergeNums, int start, int end) {
        if (start >= end) {
            return;
        }
        int mid = (end - start) / 2 + start;
        sort(mergeNums, start, mid);
        sort(mergeNums, mid + 1, end);
        merge(mergeNums, start, mid, end);
    }

    public static void merge(int[] mergeNums, int start, int mid, int end) {
        int l = start;
        int m = mid + 1;
        int t = 0;
        int[] temp = new int[mergeNums.length];
        while (l <= mid && m <= end) {
            if (mergeNums[l] <= mergeNums[m]) {
                temp[t++] = mergeNums[l++];
            } else {
                temp[t++] = mergeNums[m++];
            }
        }
        while (l <= mid) {
            temp[t++] = mergeNums[l++];
        }
        while (m <= end) {
            temp[t++] = mergeNums[m++];
        }
        if (end - start >= 0) {
            System.arraycopy(temp, 0, mergeNums, start, end - start + 1);
        }
    }
}
```

**堆排序代码：**
```
public class Solution {
    public static void heapSort(int[] array) {
        //这里元素的索引是从0开始的,所以最后一个非叶子结点array.length/2 - 1
        for (int i = array.length / 2 - 1; i >= 0; i--) {
            adjustHeap(array, i, array.length);  //调整堆
        }
        System.out.println("sort1: " + Arrays.toString(array));
        // 上述逻辑，建堆结束
        // 下面，开始排序逻辑
        for (int j = array.length - 1; j > 0; j--) {
            // 元素交换,作用是去掉大顶堆
            // 把大顶堆的根元素，放到数组的最后；换句话说，就是每一次的堆调整之后，都会有一个元素到达自己的最终位置
            swap(array, 0, j);
            // 元素交换之后，毫无疑问，最后一个元素无需再考虑排序问题了。
            // 接下来我们需要排序的，就是已经去掉了部分元素的堆了，这也是为什么此方法放在循环里的原因
            // 而这里，实质上是自上而下，自左向右进行调整的
            sort(array, 0, j);
        }
    }

    /**
     * 整个堆排序最关键的地方
     * @param array 待组堆
     * @param i 起始结点
     * @param length 堆的长度
     */
    public static void sort(int[] array, int i, int length) {
        for (int k = 2 * i + 1; k < length; k = 2 * k + 1) {  // 2 * i + 1为左子树i的左子树(因为i是从0开始的), 2 * k + 1为k的左子树
            // 让k先指向子节点中最大的节点
            if (k + 1 < length && array[k] < array[k + 1]) {  // 如果有右子树,并且右子树大于左子树
                k++;
            }
            //如果发现结点(左右子结点)大于根结点，则进行值的交换
            if (array[i] < array[k]) {
                swap(array, i, k);
                // 如果子节点更换了，那么，以子节点为根的子树会受到影响,所以，循环对子节点所在的树继续进行判断
                i = k;
            } else {  //不用交换，直接终止循环
                break;
            }
        }
    }

    public static void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```

**解题思路：**
- 快速排序：定一个基准值，比基准值小的放在前（后）面，比基准值大的放在后（前）面，取决于升序还是降序。
- 归并排序：将给定长度为n的数组拆分成n个长度为1的子数组，两两合并，合并时按升序（降序）合并即可。
- 堆排序：根据给定的数组构建大顶堆（小顶堆），随后依次将最后一个元素和对顶元素交换，并重新调整堆。

---

### [215. 数组中的第K个最大元素（Medium）](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例：**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**快排思想代码：**
```
public class Solution {
    public static int findKthLargest(int[] nums, int k) {
        return heapSelect(nums, k);
    }

    public static int quickSelect(int[] nums, int left, int right, int k) {

        int random = (int) (Math.random() * (right - left + 1)) + left;
        swap(nums, left, random);

        int index = right + 1;
        int pivot = nums[left];
        for (int i = right; i > left; i--) {
            if (nums[i] <= pivot) {
                index--;
                swap(nums, index, i);
            }
        }
        index--;
        swap(nums, index, left);

        if (index == k) {
            return nums[index];
        } else if (index < k) {
            return quickSelect(nums, index + 1, right, k);
        } else {
            return quickSelect(nums, left, index - 1, k);
        }
    }

    public static void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```

**堆思想代码：**
```
public class Solution {
    public static int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, 0, nums.length - 1, k - 1);
    }

    public static int heapSelect(int[] nums, int k) {
        int length = nums.length;
        for (int i = length / 2; i >= 0; i--) {
            heapSort(nums, i, length);
        }
        for (int i = length - 1; i > 0; i--) {
            swap(nums, i, 0);
            heapSort(nums, 0, i);
            if (k == length - i) {
                return nums[i];
            }
        }
        return nums[0];
    }

    public static void heapSort(int[] nums, int root, int length) {
        for (int k = 2 * root + 1; k < length; k = 2 * root + 1) {
            if (k + 1 < length && nums[k] < nums[k + 1]) {
                k++;
            }
            if (nums[root] < nums[k]) {
                swap(nums, root, k);
                root = k;
            } else {
                break;
            }
        }
    }

    public static void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```

**解题思路：**
主要思路：将比自己大的元素放前面，比自己小的元素放后面。

快排思想：

- 当前元素的下标刚好为k-1时（因为k从1开始，元素下标从0开始），该元素刚好为第k大元素。
- 当元素下标比k小时，当前元素及前面的元素都比数组后面的元素大，所以要排序后面的元素。
- 当元素下标比k大时，当前元素及后面的元素都比数组前面的元素小，所以要排序前面的元素。

堆思想：
- 维护一个size为k的小顶堆，遍历一次数组后堆顶元素即为第k大元素。

---

### [347. 前 K 个高频元素（Medium）](https://leetcode-cn.com/problems/top-k-frequent-elements/)
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

**示例：**
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**代码：**
```
public class Solution {
    public static int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> statisticsMap = new HashMap<>();
        MyPriorityQueue priorityQueue = new MyPriorityQueue(k);
        for (int num : nums) {
            statisticsMap.merge(num, 1, Integer::sum);
        }

        for (Map.Entry<Integer, Integer> entry : statisticsMap.entrySet()) {
            if (priorityQueue.size() < k) {
                priorityQueue.offer(entry.getKey(), statisticsMap);
            } else {
                if (entry.getValue() > statisticsMap.get(priorityQueue.peek())) {
                    priorityQueue.poll(statisticsMap);
                    priorityQueue.offer(entry.getKey(), statisticsMap);
                }
            }
        }

        int[] result = new int[k];
        for (int i = 0; i < k; i++) {
            result[i] = priorityQueue.get(i);
        }
        return result;
    }
    
}

public class MyPriorityQueue {

    private int size;
    private int[] array;

    MyPriorityQueue() {
        this.size = 0;
        this.array = new int[16];
    }

    MyPriorityQueue(int size) {
        this.size = 0;
        this.array = new int[size];
    }

    public int size() {
        return size;
    }

    public Integer peek() {
        return size == 0 ? null : array[0];
    }

    public void offer(int num, HashMap<Integer, Integer> statisticsMap) {
        if (size >= array.length) {
            int[] newArray = new int[2 * array.length];
            System.arraycopy(array, 0, newArray, 0, array.length);
            array = newArray;
        }
        array[size++] = num;
        floatUp(statisticsMap);
    }

    public void poll(HashMap<Integer, Integer> statisticsMap) {
        if (size == 0) {
            return;
        }
        array[0] = array[size - 1];
        size--;
        sink(statisticsMap);
    }

    public int get(int index) {
        if (index > size) {
            return -1;
        }
        return array[index];
    }

    private void floatUp(HashMap<Integer, Integer> statisticsMap) {
        int root = size - 1;
        if (root == 0) {
            return;
        }
        while (root > 0) {
            int leftChild;
            Integer rightChild = null;
            if (root % 2 == 0) {
                leftChild = root - 1;
                rightChild = root;
            } else {
                leftChild = root;
            }
            int largest = rightChild == null ? leftChild : statisticsMap.get(array[leftChild]) < statisticsMap.get(array[rightChild]) ? leftChild : rightChild;
            int parent = (leftChild - 1) / 2;
            if (statisticsMap.get(array[largest]) < statisticsMap.get(array[parent])) {
                swap(array, largest, parent);
            }
            root = parent;
        }
    }

    private void sink(HashMap<Integer, Integer> statisticsMap) {
        int root = 0;
        for (int k = 1; k < size; k = 2 * root + 1) {
            if (k + 1 < size && statisticsMap.get(array[k]) > statisticsMap.get(array[k + 1])) {
                k++;
            }
            if (statisticsMap.get(array[root]) <= statisticsMap.get(array[k])) {
                break;
            }
            swap(array, root, k);
            root = k;
        }
    }

    private void swap(int[] nums, i nt index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }

    @Override
    public String toString() {
        if (array == null)
            return "null";
        int iMax = size - 1;
        if (iMax == -1)
            return "[]";

        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (int i = 0; ; i++) {
            sb.append(array[i]);
            if (i == iMax)
                return sb.append(']').toString();
            sb.append(", ");
        }
    }
}
```

**解题思路：**
首先利用桶排序统计每个元素出线的频率，然后建立一个size为k的小顶堆，当size < k时，元素直接加入堆。
当size >= k时，则要先把当前元素的和堆顶元素作比较，若比堆顶元素大，则取出堆顶元素，并把当前元素放入堆中。

---

## 6. 深度优先搜索
- 深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言，
由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。
- 深度优先搜索也可以用来检测环路：记录每个遍历过的节点的父节点，若一个节点被再次遍
历且父节点不同，则说明有环。我们也可以用之后会讲到的拓扑排序判断是否有环路，若最后存
在入度不为零的点，则说明有环。
- 有时我们可能会需要对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这
种做法叫做状态记录或记忆化（memoization）。

---

### [695. 岛屿的最大面积（Medium）](https://leetcode-cn.com/problems/max-area-of-island/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
给你一个大小为 m x n 的二进制矩阵 grid 。

岛屿是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

岛屿的面积是岛上值为 1 的单元格的数目。

计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。

**示例：**
![image](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)
```
输入：grid = [
                [0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],
                [0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],
                [0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],
                [0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]
             ]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

**代码：**
```
public class Solution {
    public static int maxAreaOfIsland(int[][] grid) {
        int maxSize = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] != 0) {
                    maxSize = Math.max(maxSize, dfs(grid, i, j));
                }
            }
        }
        return maxSize;
    }

    public static int dfs(int[][] grid, int row, int col) {
        if (row < 0 || row >= grid.length) {
            return 0;
        }
        if (col < 0 || col >= grid[0].length) {
            return 0;
        }
        if (grid[row][col] == 0) {
            return 0;
        } else {
            grid[row][col] = 0;
            return dfs(grid, row - 1, col) + dfs(grid, row + 1, col) +
                   dfs(grid, row, col - 1) + dfs(grid, row, col + 1) + 1;
        }
    }
}
```

**解题思路：**
每当遇到一个值为 1 的元素，先将自身置为 0，表示已经遍历过，然后遍历其上下左右四个相邻节点，保留最大值即可。

---

### [417. 太平洋大西洋水流问题（Medium）](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)
给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

**示例：**
```
给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
```

**代码：**
```
public class Solution {
    private int m, n;
    private int[][] direction = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private boolean in_area(int x, int y){
        return 0 <= x && x < m && 0 <= y && y < n;
    }
    private void dfs(int[][] matrix, int x, int y, int[][] tmp){
        tmp[x][y] = 1;
        for (int[] d : direction) {
            int newx = x + d[0];
            int newy = y + d[1];
            if (!in_area(newx, newy) || matrix[x][y] > matrix[newx][newy] || tmp[newx][newy] == 1){
                continue;
            }
            dfs(matrix, newx, newy, tmp);
        }
    }
    public List<List<Integer>> pacificAtlantic(int[][] matrix) {
        List<List<Integer>> ans = new ArrayList<>();
        if (matrix == null || matrix.length == 0)
            return ans;
        m = matrix.length;
        n = matrix[0].length;
        int[][] po = new int[m][n], ao = new int[m][n]; //po 太平洋，ao 大西洋
        for (int i = 0; i < n; ++i){
            dfs(matrix, 0, i, po);
            dfs(matrix, m - 1, i, ao);
        }
        for (int i = 0; i < m; ++i){
            dfs(matrix, i, 0, po);
            dfs(matrix, i, n - 1, ao);
        }
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (po[i][j] == 1 && ao[i][j] == 1){
                    ans.add(Arrays.asList(i, j));
                }
            }
        }
        return ans;
    }
}
```

**解题思路：**
对于此题我们可以直观的取暴力搜索每一个点是否可以达到两边的大洋，当然这样子要处理的东西会很多，并且思路不够明显。

对于一个点它能流动两边的大洋，那么反过来，两边大洋的水反着流就能达到这个点。
尽然水开始倒流了，那么逻辑也需要反过来，因此只有将下一个点比当前的点大时或者等于当前点的高度时，水才能流过去。

---

### [51. N 皇后（Hard）](https://leetcode-cn.com/problems/n-queens/)
n 皇后问题研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

**示例：**
![image](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)
```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**代码：**
```
public class Solution {
    private static boolean[] colVisited;
    private static boolean[] leftDiagonalVisited;
    private static boolean[] rightDiagonalVisited;

    public static List<List<String>> solveNQueens(int n) {
        colVisited = new boolean[n];
        leftDiagonalVisited = new boolean[2 * n - 1];
        rightDiagonalVisited = new boolean[2 * n - 1];
        List<List<String>> resultList = new ArrayList<>();
        dfs(resultList, new ArrayList<>(), n, 0);
        return resultList;
    }

    public static void dfs(List<List<String>> resultList, List<Integer> currentList, int n, int currentRow) {
        if (currentRow == n) {
            List<String> list = new ArrayList<>();
            for (Integer integer : currentList) {
                StringBuilder stringBuilder = new StringBuilder();
                for (int j = 0; j < n; j++) {
                    if (j == integer) {
                        stringBuilder.append('Q');
                    } else {
                        stringBuilder.append('.');
                    }
                }
                list.add(stringBuilder.toString());
            }
            resultList.add(list);
            return;
        }
        for (int i = 0; i < n; i++) {
            if (colVisited[i] || leftDiagonalVisited[currentRow + i] || rightDiagonalVisited[currentRow + n - i - 1]) {
                continue;
            }
            colVisited[i] = true;
            leftDiagonalVisited[currentRow + i] = true;
            rightDiagonalVisited[currentRow + n - i - 1] = true;
            currentList.add(i);
            dfs(resultList, currentList, n, currentRow + 1);
            currentList.remove(currentList.size() - 1);
            colVisited[i] = false;
            leftDiagonalVisited[currentRow + i] = false;
            rightDiagonalVisited[currentRow + n - i - 1] = false;
        }
    }
}
```

**解题思路：**
- 从第一行选择一个点，将其所在行，所在列，左斜，右斜标记为已经访问，并且将其记录到当前路径中
- 继续到下一行，选择下一个合法的点（遍历当前行所有的点，判断是否合法，依据所在行，所在列，左斜，右斜的标记数组）
- 如果不合法，则回溯到上一个过程，重新选择
- 当递归到底时，便获取到了一个合法的解

---

## 7. 广度优先搜索
- 广度优先搜索（breadth - first search，BFS）不同与深度优先搜索，它是一层层进行遍历的，因此需要用先入先出的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时按照“广”的方向进行遍历的，也常常用来处理最短路径等问题。

---

### [934. 最短的桥（Medium）](https://leetcode-cn.com/problems/shortest-bridge/)
在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）

现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。

返回必须翻转的 0 的最小数目。（可以保证答案至少是 1。）

**示例：**
```
输入：A = [[0,1],[1,0]]
输出：1
```

**代码：**
```
public class Solution {
    // 用来转换方向
    private static final int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

    public static int shortestBridge(int[][] grid) {
        // 记录下来整个图的尺寸
        int n = grid.length, m = grid[0].length;
        // 标记哪些位置已经访问过了
        boolean[][] visited = new boolean[n][m];
        // 标记是否找到第一个小岛了
        boolean findIsland = false;
        // 记录第一个小岛的边界
        Queue<int[]> board = new LinkedList<>();
        // 去标记第一个小岛，将原来的 1 改成 2
        for (int x = 0; x < n && !findIsland; ++x) {
            for (int y = 0; y < m && !findIsland; ++y) {
                if (!visited[x][y] && grid[x][y] == 1) {
                    mark(grid, visited, x, y, 2, board);
                    findIsland = true;
                }
            }
        }
        // 记录距离
        int ans = 0;
        while (!board.isEmpty()) {
            // 记录当前需要遍历的边界数量
            int size = board.size();
            for (int i = 0; i < size; ++i) {
                // 取出来下一个要检查的坐标
                int[] next = board.poll();
                for (int j = 0; j < 4; ++j) {
                    // 对这个坐标进行上下左右检查
                    assert next != null;
                    int nx = next[0] + dirs[j][0];
                    int ny = next[1] + dirs[j][1];
                    // 如果这个新坐标合法，而且没有访问过，就对其进行检查
                    if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]) {
                        visited[nx][ny] = true; // 首先标记成访问过了
                        // 如果接触到了第二个小岛，那么直接返回距离计数器 ans
                        if (grid[nx][ny] == 1) return ans;
                            // 否则的话，就放到边界队列中
                        else board.add(new int[]{nx, ny});
                    }
                }
            }
            // 边界计数器加一
            ++ans;
        }
        return ans;
    }

    /**
     * 对 grid 中的一个小岛进行标记
     * @param grid      小岛描述图
     * @param visited   标记某个坐标是否访问过了
     * @param x         出发点 [x, y]
     * @param y         出发点 [x, y]
     * @param color     要标记成的颜色
     * @param board     用来保存边界的队列
     */
    private static void mark(int[][] grid, boolean[][] visited, int x, int y, int color, Queue<int[]> board) {
        grid[x][y] = color;
        // 判断是不是边界，是的话就直接放到队列中
        if (x == 0 || y == 0 || x == grid.length - 1 || y == grid[0].length - 1 ||
                grid[x + 1][y] == 0 || grid[x - 1][y] == 0 || grid[x][y + 1] == 0 || grid[x][y - 1] == 0) {
            board.add(new int[]{x, y});
        }
        // 对 [x, y] 上下左右四个方向进行拓展检查
        for (int i = 0; i < 4; ++i) {
            int nx = x + dirs[i][0];
            int ny = y + dirs[i][1];
            // 对小岛进行扩展查找
            if (nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[0].length && !visited[nx][ny] && grid[nx][ny] == 1) {
                visited[nx][ny] = true;
                mark(grid, visited, nx, ny, color, board);
            }
        }
    }
}
```

**解题思路：**
先标记其中一个小岛为 2，然后从这个小岛出发，一层一层的扩散，当碰到另一个小岛时返回即可。

---

### [126. 单词接龙 II（Hard）](https://leetcode-cn.com/problems/word-ladder-ii/)
按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：

- 每对相邻的单词之间仅有单个字母不同。
- 转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。
- sk == endWord
给你两个单词 beginWord 和 endWord ，以及一个字典 wordList。请你找出并返回所有从 beginWord 到 endWord 的最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。

**示例：**
```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot", "dot", "dog", "lot", "log", "cog"]
输出：[["hit", "hot", "dot", "dog", "cog"], ["hit", "hot", "lot", "log", "cog"]]
解释：存在 2 种最短的转换序列：
"hit" -> "hot" -> "dot" -> "dog" -> "cog"
"hit" -> "hot" -> "lot" -> "log" -> "cog"
```

**代码：**
```
public class Solution {
    public static List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> ans = new ArrayList<>();
        // 如果不含有结束单词，直接结束，不然后边会造成死循环
        if (!wordList.contains(endWord)) {
            return ans;
        }
        bfs(beginWord, endWord, wordList, ans);
        return ans;
    }

    public static void bfs(String beginWord, String endWord, List<String> wordList, List<List<String>> ans) {
        Queue<List<String>> queue = new LinkedList<>();
        List<String> path = new ArrayList<>();
        path.add(beginWord);
        queue.offer(path);
        boolean isFound = false;
        Set<String> dict = new HashSet<>(wordList);
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);
        while (!queue.isEmpty()) {
            int size = queue.size();
            Set<String> subVisited = new HashSet<>();
            for (int j = 0; j < size; j++) {
                List<String> p = queue.poll();
                //得到当前路径的末尾单词
                assert p != null;
                String temp = p.get(p.size() - 1);
                // 一次性得到所有的下一个的节点
                ArrayList<String> neighbors = getNeighbors(temp, dict);
                for (String neighbor : neighbors) {
                    //只考虑之前没有出现过的单词
                    if (!visited.contains(neighbor)) {
                        //到达结束单词
                        if (neighbor.equals(endWord)) {
                            isFound = true;
                            p.add(neighbor);
                            ans.add(new ArrayList<>(p));
                            p.remove(p.size() - 1);
                        }
                        //加入当前单词
                        p.add(neighbor);
                        queue.offer(new ArrayList<>(p));
                        p.remove(p.size() - 1);
                        subVisited.add(neighbor);
                    }
                }
            }
            visited.addAll(subVisited);
            if (isFound) {
                break;
            }
        }
    }

    private static ArrayList<String> getNeighbors(String node, Set<String> dict) {
        ArrayList<String> res = new ArrayList<String>();
        char[] chs = node.toCharArray();
        for (char ch = 'a'; ch <= 'z'; ch++) {
            for (int i = 0; i < chs.length; i++) {
                if (chs[i] == ch)
                    continue;
                char old_ch = chs[i];
                chs[i] = ch;
                if (dict.contains(String.valueOf(chs))) {
                    res.add(String.valueOf(chs));
                }
                chs[i] = old_ch;
            }

        }
        return res;
    }
}
```

**解题思路：**
使用广度优先搜索，一层一层递进，当到达结束单词时，即为最小。
